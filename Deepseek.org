#+title: Deepseek v1
We are going to create a script that transforms Fedora 42 into a source-based distribution.

However, note that Fedora 42 does not exist as of my knowledge cutoff (2023). We'll assume it's a future version.

We are going to mimic some Gentoo features but using Fedora's infrastructure.

Steps:

1. We will use `dnf` for dependency resolution and fetching source RPMs (SRPMs).

2. We will build from source using `rpmbuild` and then install the resulting RPMs.

3. We will have a mechanism to check for newer versions in testing, rawhide, or git (if available).

4. We'll avoid rebuilding the kernel from source by default (as per exception).

5. We will handle both Fedora repositories and RPM Fusion.

The script will have the following features:

- Install necessary build tools.

- For each package to install (or update), download the source RPM (SRPM) from the repository.

- If a newer version is available in testing or rawhide, use that SRPM.

- Build the SRPM into RPMs in a chroot or isolated environment to avoid breaking the host.

- Install the built RPMs.

- Handle build dependencies by recursively building and installing them first.

- Avoid rebuilding the same dependency multiple times by keeping track of built packages.

- Allow building packages from GitHub (or other VCS) for packages not in repositories.

We'll create a class-based structure to manage the build process.

Important: This is a complex task and the script below is a conceptual framework.

It may not cover all edge cases and should be tested thoroughly.

Steps in the script:

1. Setup:

- Install necessary packages: `dnf-plugins-core`, `rpmdevtools`, `mock` (for building in a chroot)

- Set up the build environment (e.g., `rpmdev-setuptree`)

2. Dependency tracking:

- We will maintain a set (or a graph) of packages to build, with their dependencies.

3. For each package (starting from the command line arguments, then dependencies):

a. Check available versions in Fedora repos (stable, updates, updates-testing, rawhide) and RPM Fusion.

b. Choose the latest version (except kernel).

c. Download the SRPM.

d. If the package is not in any repo, but a GitHub (or other) URL is provided, create a spec file and SRPM.

4. Build order:

- We need to build dependencies first. We can use a topological sort based on dependency graph.

5. Building:

- Use `rpmbuild` or `mock` to build the SRPM and produce RPMs.

- Install the built RPMs.

6. Avoiding duplicate builds:

- Keep a cache of already built packages.

7. Custom packages from GitHub:

- We'll have a mechanism to convert a GitHub source into an SRPM (using `rpmdev-newspec` or a template).

Implementation:

We'll create a class `SourceFedora` that handles:

- Configuration (repos, directories, etc.)

- Dependency resolution

- Downloading SRPMs

- Building and installing

Due to the complexity, we'll break down the tasks.

Note: This script must be run as root.

However, note that building in a chroot with mock doesn't require root, but we are installing the built RPMs on the system so we need root.

We'll use:

- `dnf repoquery` for dependency resolution and version checking.

- `dnf download --source` for downloading SRPMs.

- `mock` for building in a chroot (to avoid dependency issues on the host).

Alternatively, we can use `rpmbuild` on the host but that might cause dependency conflicts during build.

Let's design:

Steps:

1. Initialize:

- Create a temporary workspace.

- Set up rpmbuild tree if not exists.

2. For a given package name (or list):

- Resolve the latest version from enabled repos (and also check testing, rawhide if enabled by user).

- Download the SRPM.

3. For the SRPM, we need to get the build dependencies (using `dnf builddep` might help, but we want to build them too).

4. Recursively process build dependencies.

5. Build the package and install.

We'll use a global set of processed packages to avoid rebuilding.

However, the challenge is in circular dependencies and version constraints.

We'll do a simple depth-first resolution, but note that we might get stuck in cycles.

We'll keep a set of packages that are currently in the build stack to detect cycles.

We'll also allow the user to specify prebuilt packages (like the toolchain) to break cycles.

Implementation of the build process:

We'll use a dictionary to track:

package: (version, repo, srpm_path, built_rpms)

Steps for a package:

def build_package(pkg_name):

if pkg_name in installed_cache:

return

if pkg_name in build_stack: # cycle detection

error

build_stack.add(pkg_name)

# Get the latest version and source URL

version_info = get_latest_version(pkg_name)

# Download SRPM to a temp location

srpm_path = download_srpm(pkg_name, version_info)

# Extract the spec file and sources?

# Instead, we can use `rpm -qpi` and `rpm -qRp` to get build deps.

# Get build dependencies (requires from spec file)

build_deps = get_build_deps(srpm_path)

for dep in build_deps:

if dep not in installed_cache and dep not in build_stack:

build_package(dep)

# Now build the package

build_with_mock(srpm_path)

# Install the built RPMs

install_rpms(built_rpms)

installed_cache.add(pkg_name)

build_stack.remove(pkg_name)

But note: build dependencies might be virtual packages. We need to map to real packages.

How to get build dependencies from an SRPM?

We can install the SRPM and extract the spec file? Or use `rpm` commands:

rpm -q --requires -p <srpm>   # This doesn't work for SRPM? Actually, we can use `rpm2cpio` and extract the spec.

Alternatively, use `rpmspec -q --buildrequires <spec_file>` but we need to extract the spec.

We can use:

rpm -i <srpm>   # to install the spec and sources in the rpmbuild tree? But that might interfere.

Instead, we can use `dnf builddep <srpm>` to list the build dependencies? But we want to build them.

Actually, we can use:

dnf repoquery --requires --resolve --srpm <srpm_path>

But that might not be accurate until we have the spec.

Alternatively, we can use `mock` to build in a clean chroot and let it fail due to missing dependencies, then install them?

But we want to control the process.

Given the complexity, we might rely on `dnf builddep` to install build dependencies from binaries? But that breaks the source-based idea.

Our goal is to build everything from source. So we must build the build dependencies from source too.

How to get the list of build dependencies without building?

We can extract the spec file from the SRPM:

rpm2cpio mypackage.src.rpm | cpio -i --to-stdout '*.spec' > mypackage.spec

Then parse the spec file for BuildRequires.

But note: BuildRequires can have conditionals and macros. This is complex.

Alternatively, we can use the `rpmspec` command to parse the spec:

rpmspec -q --buildrequires mypackage.spec

This will expand the macros and give us the build dependencies.

But we must have the spec file and the environment set up? We can do this in a mock chroot?

Due to the complexity, we might decide to first build the build dependencies as binary packages using dnf? But that would break the source-based principle.

We are in a dilemma.

Alternatively, we can use a hybrid approach:

- For build dependencies, we first try to build them from source.

- If we cannot (because of complexity or circularity), we allow installing the binary.

But note: the goal is to be source-based. So we must build everything.

We'll try to build the build dependencies from source. We'll rely on `dnf repoquery` to resolve the build dependency to a package name.

Steps:

Let the build dependency be a string (e.g., "python3-devel >= 3.6")

We can use:

dnf repoquery --whatprovides "python3-devel >= 3.6"

This will give us the package that provides that capability.

Then we build that package.

However, note that the capability might be provided by multiple packages. We need to choose one.

We'll choose the one that is the preferred provider (usually the one with the highest version).

So we'll write a function:

resolve_dependency(dep_string) -> list of packages (with versions) that provide it.

Then we choose the best one.

But note: we are building from source, so we must have the SRPM for that package.

We'll then recursively build that package.

This is a very ambitious project and might take a long time to build a system.

We'll write the script in a modular way, but note that it might be too slow for practical use.

We'll also add an option to skip building certain packages (like the toolchain) and use the binary.

We'll start by building a prototype for one package.

We'll assume that the build dependencies are already available in binary form? That breaks our goal.

Alternatively, we can pre-build a set of essential packages (like glibc, gcc, etc.) and then use those to build the rest.

We might need to bootstrap.

Given the time constraints, we'll design the script for non-bootstrap scenario and assume that the build tools (gcc, glibc, etc.) are installed as binaries.

We'll build everything else from source.

We'll create a configuration file to list packages that are pre-installed (binary) and should not be rebuilt.

Steps for the script:

Pre-install build tools (as binary):

dnf install -y @buildsys-build mock

Set up the user for mock? (if needed)

Initialize the rpmbuild tree:

rpmdev-setuptree

We'll have:

SourceFedora class:

Attributes:

config: configuration (repos, prebuilt_packages, etc.)

build_dir: directory for building

rpmbuild_root: the rpmbuild directory (e.g., ~/rpmbuild)

installed_cache: set of packages (name-version-release) that are built and installed.

prebuilt_pkgs: set of prebuilt package names (or provides) that we don't build.

Methods:

__init__(self, config)

enable_repos(self)   # enable fedora, updates, updates-testing, rpmfusion, etc.

get_latest_version(pkg_name)   # returns (version, release, repo, srpm_url)

download_srpm(pkg_name, version_info)   # downloads and returns path to SRPM

extract_spec(srpm_path)   # extracts the spec file and returns its path

parse_build_deps(spec_path)   # returns a list of build dependencies (as strings)

resolve_dep(dep_string)   # returns a list of packages that provide the dep, then choose the best one.

build_package(pkg_name)   # the main recursive function

build_with_mock(srpm_path)   # builds the SRPM in a mock chroot and returns the path to the built RPMs

install_rpms(rpm_files)   # installs the RPMs with rpm -i

We'll also have a function to create an SRPM from a GitHub source.

We'll create a helper for GitHub:

create_srpm_from_github(github_url)   # clones, creates a spec file (if not present) and builds an SRPM.

Due to the vastness of the task, we will implement a minimal version.

Note: This script is for educational purposes and might not be complete.

Let's start coding the structure.

IMPORTANT: This script is not production-ready. It's a proof of concept.

We'll write the script step by step.

We'll skip some complex parts (like cycle detection and complex dependency resolution) for brevity.

We'll also assume that the build dependencies are already available in the repositories (so we can get their SRPMs).

We'll not handle packages that are not in the repositories (from GitHub) in the first version.

We'll focus on building one package and its build dependencies from Fedora repositories.

We'll use:

dnf config-manager --set-enabled updates-testing   # to enable testing

We'll write the script for Fedora 42, but we'll use variables for release.

Let's start.
