Comprehensive Guide: Setting Up SELinux Policy for Nix on Fedora Workstation 42I. Introduction to SELinux and Nix IntegrationOverview of SELinux's Role in Fedora SecuritySecurity-Enhanced Linux (SELinux) represents a fundamental enhancement to the Linux kernel's security model, operating as a Mandatory Access Control (MAC) system that significantly bolsters traditional Discretionary Access Control (DAC). Its foundational principle is one of "deny by default," which means that every access request on the system is explicitly denied unless a loaded SELinux policy rule grants permission.1 Fedora Workstation 42, like its predecessors, ships with SELinux enabled and configured in enforcing mode by default. It employs a targeted policy, which focuses on confining specific services and applications, thereby limiting their potential impact should they be compromised, while allowing other less critical components to operate with broader permissions.1At the core of SELinux's operation is the concept of a security context. Every process, file, and other system object is labeled with a unique security context, typically structured as SELinux_user:role:type:level. These contexts are the essential metadata SELinux uses to make all access control decisions. Policy rules precisely define how these various contexts are permitted to interact with one another. This granular control is vital for mitigating damage from system misconfigurations or successful exploits, as it strictly limits the capabilities of any process to only what is absolutely necessary for its intended function.1Introduction to Nix's Unique Package Management ParadigmNix distinguishes itself as a purely functional package manager, designed to build software packages in isolated environments. A cornerstone of its design is the immutable /nix/store directory, which serves as the central repository for all packages and their dependencies. Each item within this store is content-addressed, meaning its path includes a cryptographic hash of its inputs (e.g., /nix/store/k13mm9jqxm2ndlwzsj7zicsq7lpmmjlg-elixir-1.7.3). This innovative approach guarantees unparalleled reproducibility, effectively eliminates dependency conflicts, and facilitates advanced features such as atomic upgrades and rollbacks, as well as the side-by-side installation of different versions of the same software.4In stark contrast to conventional package managers that scatter files across standard Unix directories like /usr/bin, /usr/lib, or /etc, Nix constructs user and system-wide "profiles." These profiles are essentially intricate collections of symbolic links that point directly into the immutable paths within the /nix/store.4 This design philosophy underpins Nix's functional purity and its ability to manage software environments with exceptional precision.The Inherent Challenges of Integrating Nix's Immutable Store with SELinux's Mandatory Access ControlThe integration of Nix with SELinux presents inherent complexities, primarily stemming from the fundamental differences in their operational paradigms. SELinux policies are heavily reliant on predefined, static file paths to assign and enforce security contexts.1 However, Nix's /nix/store is characterized by a vast number of uniquely hashed and dynamically generated directories and files, a structure that is inherently unknown to the standard Fedora SELinux policy.4This architectural divergence creates a significant challenge. When processes attempt to access files or execute binaries directly from /nix/store, or when Nix itself performs core operations (such as building new packages or managing user profiles), SELinux is highly prone to generating Access Vector Cache (AVC) denials. These denials occur because the paths within /nix/store lack appropriate security labels, or the default policy simply does not contain rules that permit the required interactions with this non-standard filesystem hierarchy.6Furthermore, Nix's extensive reliance on symbolic links introduces an additional layer of complexity for SELinux. If these symlinks themselves, or their ultimate targets, do not possess the correct security labels, or if the policy does not explicitly allow the following of symlinks of a certain type, access can be unexpectedly denied.6 For multi-user Nix installations, the nix-daemon operates as a privileged service. Its interactions with the /nix directory and its associated Unix domain socket (/nix/var/nix/daemon-socket/socket) necessitate specific SELinux permissions that are not typically present in a default Fedora policy.7One critical observation is the unseen conflict surface area that emerges from this integration. SELinux's enforcement model is deeply rooted in predefined file paths and their associated security contexts. The default Fedora policy is meticulously crafted for the standard Filesystem Hierarchy Standard (FHS). Nix, however, introduces an entirely novel and highly dynamic filesystem structure at /nix/store, where individual file paths are unique, content-addressed hashes. This means the existing, static SELinux policy has no inherent knowledge or rules for the vast majority of files within /nix. This creates a massive, systemic conflict surface area rather than isolated, predictable conflicts. The challenge extends far beyond merely granting permissions for a few specific binaries; it necessitates a fundamental shift in how SELinux is applied to Nix. A simple reactive approach using audit2allow for every single denial will be inefficient and incomplete. Instead, a more proactive and systematic approach is required: defining broad, regex-based file contexts that categorize the types of files (e.g., executables, libraries, configuration files) within the /nix/store structure, irrespective of their specific hash-prefixed paths. This fundamental mismatch between SELinux's path-centricity and Nix's content-addressed dynamism means that the system must be taught the nature of the /nix hierarchy.A second significant observation is how the multi-user installation amplifies complexity. The user's request for a "general environment" strongly points to a multi-user Nix installation. This setup introduces the nix-daemon (running as root) and specialized nixbldX users for isolated build processes.4 SELinux policies often strictly confine system daemons and limit arbitrary interactions between different user/process domains. The nix-daemon will be a central point of interaction with the /nix store and its socket, operating with elevated privileges. This architecture significantly escalates the complexity of SELinux policy configuration. It is no longer just about labeling files; it is about defining a specific SELinux domain for the nix-daemon process itself, establishing precise rules for its interactions with the /nix store, its Unix domain socket, and enabling secure domain transitions for the nixbldX users during build operations. The inherent security benefits of Nix's multi-user build isolation are directly dependent on, and challenged by, SELinux's default "deny all" posture for unknown or unpermitted interactions, requiring careful policy crafting to avoid both over-permissiveness and functional breakage.II. Understanding SELinux Fundamentals for Nix IntegrationSELinux Contexts: User, Role, Type, and LevelIn an SELinux-enabled system, every object—be it a file, directory, process, or network port—is labeled with a comprehensive security context.1 This context adheres to a standard format: SELinux_user:role:type:level.SELinux User: This identity, known to the SELinux policy, is mapped from a traditional Linux user account. It dictates the set of roles and Multi-Level Security (MLS)/Multi-Category Security (MCS) ranges that the user is authorized for.1Role: As an attribute of Role-Based Access Control (RBAC), roles serve as an intermediary. SELinux users are authorized to assume specific roles, and these roles, in turn, are authorized to enter particular domains.1Type: This is arguably the most critical component for Type Enforcement (TE). The type defines a "domain" for processes and a "type" for files and other objects. SELinux policy rules primarily govern how these types can interact with each other (e.g., a process domain accessing a file type, or one process domain interacting with another).1 Conventionally, most SELinux types end with _t (e.g., httpd_t for the Apache web server process, passwd_exec_t for the password utility executable, shadow_t for the shadow password file).1Level: This field is utilized for MLS or MCS. Fedora's targeted policy typically enforces MCS, which uses a single sensitivity s0 and supports 1024 different categories, c0 through c1023.1 For standard desktop workstation use, the level is commonly s0.For example, the SELinux context system_u:object_r:passwd_exec_t:s0 for the /usr/bin/passwd executable illustrates these fields: system_u is the SELinux user, object_r is the role, passwd_exec_t is the type, and s0 is the security level.1Type Enforcement (TE) and its Importance for File and Process LabelingType Enforcement forms the bedrock of SELinux policy enforcement in Fedora. It dictates access decisions based predominantly on the type field of the SELinux context.1 For example, a process running within the httpd_t domain is explicitly permitted to read files labeled httpd_sys_content_t but will be denied access to files labeled samba_share_t.2Processes achieve domain transitions by executing applications that are labeled with an entrypoint type specifically defined for the new domain. This mechanism ensures that applications and services operate with the minimum necessary privileges, thereby limiting their potential for harm.1How SELinux Policy is Enforced and LoadedDuring the boot process, the SELinux kernel module initializes and is hardcoded to run with the kernel_t context. It then loads the comprehensive SELinux policy file into the kernel. Subsequently, the init process (systemd) re-executes itself, transitioning from kernel_t to init_t based on predefined policy rules.3 This chain of controlled domain transitions continues as various system services and applications are started, each transitioning into its appropriate confined domain.3All security-relevant operations at the kernel level are intercepted by SELinux. If the loaded policy contains a rule explicitly allowing the requested operation, it proceeds. Otherwise, the operation is blocked, and an Access Vector Cache (AVC) denial message is generated and logged, typically to /var/log/audit/audit.log.2 To optimize performance, SELinux decisions are cached in the Access Vector Cache (AVC), reducing the need for repeated policy lookups.2Essential SELinux UtilitiesUnderstanding and utilizing the following SELinux utilities is crucial for effective policy management and troubleshooting:ls -Z: Displays the SELinux security context alongside standard file attributes for files and directories.1getenforce: Reports the current SELinux operating mode, which can be Enforcing, Permissive, or Disabled.2setenforce 0|1: Temporarily switches SELinux to permissive mode (0) or enforcing mode (1). Changes made with setenforce are not persistent across system reboots.2semanage fcontext -a -t <type> <path_regex>: Adds or modifies persistent file context mapping rules. This command instructs SELinux how to label files and directories that match a specified regular expression pattern.5restorecon -RF <path>: Applies the file contexts defined by the current SELinux policy's rules to files and directories on disk, recursively (-R) and forcing a full relabel (-F).5ausearch -m AVC,USER_AVC -ts recent: Queries the Audit log for recent SELinux Access Vector Cache (AVC) denial messages. This is the primary tool for identifying what SELinux is blocking.7audit2allow -a -M <module_name>: Analyzes AVC denials from the audit log and generates a custom SELinux policy module in the form of a Type Enforcement (.te) file, which, if installed, would permit the previously denied actions.5checkmodule -M -m -o <module_name>.mod <module_name>.te: Compiles a SELinux Type Enforcement source file (.te) into a binary module file (.mod).13semodule_package -o <module_name>.pp <module_name>.mod: Packages the compiled .mod file into a loadable SELinux policy package (.pp file).13semodule -i <module_name>.pp: Installs the custom SELinux policy module, making its rules active on the system.13semodule -DB / semodule -B: Temporarily disables (-DB) or re-enables (-B) dontaudit rules. Disabling dontaudit rules ensures that all denials, even those typically suppressed for brevity, are logged, which is crucial for comprehensive troubleshooting.10sealert -l <alert_id>: Provides more detailed, human-readable information and often suggests solutions for specific SELinux alerts, identified by an alert ID found in the audit log messages.15One important observation is the iterative nature of policy customization. The process of creating custom SELinux policies is consistently described as iterative.7 This involves a cycle of identifying denials using ausearch, generating potential rules with audit2allow, meticulously reviewing these rules for excessive permissions, compiling and installing the policy, and then re-testing the application.7 This is not a one-time configuration task. For a complex and dynamic system like Nix, with its vast and ever-changing /nix/store, this iterative process will be particularly prolonged and demanding. Users should anticipate encountering and actively resolving numerous AVC denials, especially when new Nix packages are installed, existing ones are updated, or new features of Nix are utilized, as these actions may trigger new execution paths or file accesses that are not yet covered by the custom policy. The guide must emphasize the ongoing nature of this task and equip the user with the systematic troubleshooting loop, rather than presenting a static set of rules as a complete solution. This also underscores the critical importance of careful review of audit2allow output to prevent the creation of overly broad or insecure rules that could inadvertently undermine the system's security posture.A second critical observation is that symlinks present a hidden pitfall. SELinux explicitly differentiates between various object types, including files, directories, and symbolic links.6 A policy might permit a process to access a file with a specific type but deny access if that file is accessed via a symlink that either lacks the correct SELinux label itself or if the policy does not explicitly allow the process to follow symlinks of that particular type.6 Nix, by its very design, makes extensive use of symbolic links to construct user and system environments from the immutable store.4 This is a critical and often overlooked point for Nix integration with SELinux. Simply labeling the target files within the /nix/store might not be sufficient. The symbolic links themselves (e.g., those in user profiles like ~/.nix-profile) might also require specific SELinux contexts. Alternatively, the custom policy may need explicit rules to permit processes to follow symlinks from certain domains to the types found within the /nix/store. This adds an additional layer of complexity to the file context definitions and can be a source of unexpected audit2allow outputs. The guide must specifically instruct the user to use restorecon -RF /nix after defining file contexts, ensuring that both the symlinks and their ultimate targets are correctly labeled according to the new rules.III. Nix Package Manager: Installation and Architecture on FedoraOverview of Nix's /nix/store and its Reliance on SymlinksThe /nix/store remains the foundational component of any Nix installation, regardless of the host operating system. It is the central repository where all built packages, their dependencies, and their unique cryptographic hashes are stored.4 This immutable, content-addressed structure is a radical departure from traditional Unix filesystem layouts. User environments and system-wide installations are constructed not by copying files, but by creating intricate networks of symbolic links that point directly into these immutable store paths. For instance, on NixOS, /run/current-system is a symlink to a specific Nix store path representing the current system configuration, and application execution often involves rewritten shebangs or systemd unit ExecStart lines that reference these direct store paths.8 While Fedora Workstation doesn't operate as NixOS, the underlying principles of Nix's store and its heavy reliance on symlinks for package exposure remain consistent.Choosing the Right Nix Installation: Multi-user Setup for a "General Environment"The user's explicit request for a "general environment" strongly indicates the desirability of a multi-user Nix installation. This mode is widely considered the recommended and most robust approach for most systems, including single-user workstations, primarily due to its enhanced security features and operational consistency.4 In a multi-user setup, the /nix store and its associated database are owned by the root user. All privileged operations, particularly package builds, are offloaded to a nix-daemon.4 These builds are then executed under special, unprivileged nixbldX user accounts (e.g., nixbld1 through nixbld10), which provides crucial build isolation and prevents unprivileged users from arbitrarily modifying the central store.11 Unprivileged users interact with the nix-daemon by setting the NIX_REMOTE environment variable to daemon.11 While the multi-user daemon approach introduces more complex SELinux considerations due to the presence of privileged processes and inter-process communication, it aligns perfectly with the goal of a "general environment" that is stable, secure, and scalable.Important Note: Considering Determinate Nix Installer for SELinux CompatibilityWhile the user's query specifically requests the "official install script," it is imperative to highlight a significant development in the Nix ecosystem: the standard Nix installer has historically presented considerable challenges for SELinux-enabled Fedora systems, often necessitating temporary SELinux disabling or extensive manual policy adjustments.4 In contrast, the Determinate Nix Installer is explicitly engineered to provide seamless integration with SELinux and OSTree-based distributions. It boasts "native policy support," "full mandatory access control compatibility," and promises "zero policy conflicts" without requiring SELinux to be disabled.16For users whose primary concern is ease of setup and robust, out-of-the-box SELinux integration, the Determinate Nix Installer (curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install --determinate) represents a highly recommended and potentially superior alternative. However, in strict adherence to the user's request, this guide will proceed with the official nixos.org script, providing the necessary manual SELinux policy configuration steps. This section serves as a crucial informational note, offering the user an informed choice regarding installation methods.One significant observation is the trade-off between the "official script" and "better integration". The user specifically requested the "official install script" (from nixos.org). However, multiple research snippets indicate that this standard installer has known issues with SELinux on Fedora, often requiring SELinux to be temporarily disabled or significant manual policy work.4 Conversely, the Determinate Nix Installer explicitly advertises "seamless integration with SELinux" and "zero policy conflicts".16 This highlights a direct divergence between the "official" installation method and the "most compatible" method for SELinux environments. While the guide must prioritize fulfilling the user's explicit request for the official script, it is critical to explicitly explain why the official script poses challenges for SELinux and why Determinate Nix is a more robust solution in this specific context. This explanation justifies the extensive manual SELinux policy steps that follow and informs the user about a broader trend in the Nix ecosystem towards addressing OS-specific integration challenges. It also implies that "official" does not always equate to "optimal" for all system configurations, especially when security mechanisms like SELinux are involved.A second important observation relates to the immutability paradox and SELinux. Nix's foundational principle is the immutability of the /nix/store.4 Files within this store are content-addressed and are not designed to be modified after their initial creation, ensuring reproducibility. SELinux, conversely, applies labels to files and directories, and these labels are not inherently immutable; they can be changed and updated (e.g., via restorecon commands).5 This creates a subtle but important paradox. While the content of the /nix/store is immutable by design, its SELinux labels are not. For Nix to function correctly within an SELinux-enforced environment, its files and directories must have appropriate and dynamically manageable SELinux contexts. This means that even if a Nix package is "perfectly built" and immutable in terms of its content, its operational success on a SELinux system is contingent upon its surrounding SELinux context and labels being correctly applied and updated. This observation suggests that future, deeper Nix-SELinux integration efforts might explore methods of "baking in" SELinux contexts directly into the store paths themselves (e.g., through advanced techniques like overlay filesystems as discussed for NixOS8), rather than solely relying on host-level semanage fcontext rules. For the immediate task, the user must understand that while Nix guarantees content immutability, SELinux necessitates active label management.IV. Step-by-Step Guide: Installing Nix and Initial SELinux ConfigurationPreparationVerify SELinux StatusBefore proceeding with the Nix installation, it is essential to confirm that SELinux is active and operating in enforcing mode. This is the default configuration for Fedora Workstation 42.Check the current SELinux mode:Bashgetenforce
The expected output is Enforcing. If the output is Permissive or Disabled, set it to enforcing mode:Bashsudo setenforce 1
Install Necessary SELinux ToolsThe policycoreutils-python-utils package provides essential SELinux utilities, most notably audit2allow, which is crucial for generating custom policy rules from denial logs. These tools are indispensable for customizing SELinux policy for Nix.Install these tools:Bashsudo dnf install -y policycoreutils-python-utils
Temporary SELinux Permissive Mode for InstallationThe official Nix multi-user installer script is known to encounter various SELinux denials during its setup phase, particularly when establishing system users, groups, and configuring the nix-daemon.4 To ensure a smooth installation without blocks, it is a common and recommended practice to temporarily switch SELinux to permissive mode. In this mode, SELinux will still log all access denials to the audit log, but it will not actively prevent the operations, allowing the installation to complete. These logged denials are invaluable for later analysis and custom policy creation.2This temporary permissive mode serves a critical diagnostic purpose. By allowing all operations to proceed without blocking, permissive mode ensures that every access denial, regardless of its severity or whether it would be suppressed by dontaudit rules, is logged to the audit system. This creates a comprehensive record of all the permissions Nix requires. This step is not merely about convenience; it is a deliberate and strategic phase for gathering exhaustive SELinux access requirements. The completeness and accuracy of the subsequent custom SELinux policy are directly dependent on capturing all these initial denials. This reinforces the iterative nature of policy customization and effectively sets the stage for building a more robust and complete policy. It is important to emphasize that all critical Nix operations (e.g., initial installation, first package build, daemon startup) should be attempted while SELinux is in permissive mode to ensure a full set of AVCs is collected before any custom policy is generated.Switch SELinux to permissive mode:Bashsudo setenforce 0
Verify the mode change:Bashgetenforce
The expected output is Permissive.Nix Multi-User InstallationExecute the official Nix multi-user installation script. The -- --daemon argument is critical as it explicitly instructs the installer to set up Nix in multi-user mode, which is optimal for a "general environment" and enables the nix-daemon for privileged operations.4Run the official multi-user install script:Bashcurl -L https://nixos.org/nix/install | sh -- --daemon
Post-Installation StepsUpon successful completion, the installer will typically provide instructions to make Nix available in your current shell session.Execute this command:Bashsource $HOME/.nix-profile/etc/profile.d/nix.sh
For persistent access to Nix commands in all newly opened shell sessions, append the above source command to your shell's configuration file (e.g., ~/.bashrc for Bash users, ~/.zshrc for Zsh users).19A system reboot is highly recommended after a multi-user Nix installation. This ensures that all systemd units (including the nix-daemon), environment variables, and user/group configurations are correctly initialized and recognized by the operating system.19After reboot, verify the Nix installation by checking its version:Bashnix --version
Re-enabling SELinux Enforcing ModeOnce the Nix installation has successfully completed, it is paramount to revert SELinux to enforcing mode. Operating the system in permissive mode indefinitely significantly diminishes the security benefits provided by SELinux, leaving the system more vulnerable.2At this juncture, it is highly probable that SELinux AVC denials related to Nix operations will begin to appear. This is an expected and necessary step in the process, as it provides the raw data required for customizing your SELinux policy.The nix-daemon is a privileged and central service in a multi-user Nix setup.4 It will likely become a primary source of SELinux denials once enforcing mode is re-enabled. Its extensive interactions with the /nix store, its Unix domain socket (/nix/var/nix/daemon-socket), and potentially other system resources will necessitate explicit policy definitions. This moves beyond merely labeling files; it requires creating a dedicated SELinux type for the nix-daemon (e.g., nix_daemon_t) and meticulously defining its allowed interactions, including its ability to transition to other domains (like nixbld_t for build users) and access specific system resources. This represents a higher-level policy concern, focusing on process confinement rather than just file access.Switch SELinux back to enforcing mode:Bashsudo setenforce 1
Verify the mode change:Bashgetenforce
The expected output is Enforcing.V. Customizing SELinux Policy for NixThis section outlines the critical steps for customizing the SELinux policy to accommodate Nix's unique architecture, ensuring long-term stability and security.Identifying SELinux Denials (AVCs)Access Vector Cache (AVC) denials are the core mechanism by which SELinux logs blocked operations. These messages are logged to /var/log/audit/audit.log and can also be viewed via journalctl.7Querying Audit Logs: After re-enabling SELinux in enforcing mode and attempting various Nix operations (such as nix-shell, nix-build <package>, or installing a new package with nix-env -iA nixpkgs.<package>), SELinux will log any denied actions as AVC messages in /var/log/audit/audit.log.7Use ausearch to efficiently find recent AVC denials:Bashsudo ausearch -m AVC,USER_AVC,SELINUX_ERR,USER_SELINUX_ERR -ts recent
If ausearch yields no results, verify that the auditd daemon is running: sudo systemctl status auditd.10 Alternatively, check systemd's journal: sudo journalctl -t setroubleshoot.10Understanding AVC Message Fields: Each AVC denial message is a rich source of information, providing crucial details for diagnosis:scontext: The source security context, identifying the process that attempted the denied action.tcontext: The target security context, identifying the file or resource that was accessed.tclass: The target object class (e.g., file, dir, socket, process, capability).permissions: The specific access permission that was denied (e.g., read, write, execute, getattr, create, unlink).path: The specific file path involved in the denial.10Temporarily Disabling dontaudit Rules: In some cases, certain AVC denials might be suppressed by dontaudit rules within the active SELinux policy, meaning they won't appear in the standard audit logs. To ensure a comprehensive collection of all denials for thorough analysis:Temporarily disable dontaudit rules:Bashsudo semodule -DB
After you have collected all necessary denials, it is important to re-enable dontaudit rules to restore normal logging behavior:Bashsudo semodule -B
``` [10]

Defining File Contexts for Nix PathsThe /nix/store and other critical Nix-related directories (e.g., /nix/var/nix, /nix/etc) require specific SELinux file contexts. These contexts are essential for the nix-daemon and other processes to interact securely and correctly with Nix's unconventional filesystem hierarchy.7 By defining these contexts, SELinux is instructed on how to label files and directories within Nix's domain.Using semanage fcontext: This command is used to create persistent rules that map file paths (often using regular expressions) to specific SELinux types. This is particularly crucial for Nix because its store paths include dynamic hashes, making direct, explicit path labeling impractical. Regular expressions allow applying appropriate labels to patterns of paths.5Applying Contexts with restorecon: After defining new fcontext rules using semanage, the restorecon utility must be executed to apply these newly defined labels to the actual files and directories on disk. The -R flag ensures recursive application, and -F forces a full relabel, even if the current labels appear correct.12Bashsudo restorecon -RF /nix
Table 1: Essential SELinux File Contexts for Nix PathsThis table provides a foundational set of semanage fcontext commands. These commands establish initial, broad SELinux contexts for the primary Nix store components and critical subdirectories. These recommendations are derived from observed best practices and common requirements for Nix installations on Fedora systems.12 This table is exceptionally valuable because Nix's hash-based, dynamic paths make it practically impossible to label individual files manually. By providing regex patterns and mapping them to appropriate standard SELinux types, it offers a scalable and maintainable solution for labeling the structure of the Nix store. This directly addresses the systemic conflict surface area by providing a proactive, foundational set of rules that cover the most common categories of files and their expected security contexts within the Nix ecosystem. It shifts the approach from merely reacting to individual AVC denials to proactively establishing a secure and functional SELinux environment for Nix's unique filesystem layout.Path RegexRecommended SELinux TypeDescription/Purpose/nix/store/[^/]+/etc(/.*)?etc_tConfiguration files found within Nix store derivations./nix/store/[^/]+/lib(/.*)?lib_tLibraries and shared objects within Nix store derivations./nix/store/[^/]+/bin(/.*)?bin_tExecutable binaries within Nix store derivations./nix/store/[^/]+/sbin(/.*)?sbin_tSystem executables within Nix store derivations./nix/store/[^/]+/share(/.*)?usr_tShared data (e.g., documentation, icons) within Nix store derivations./nix/store/[^/]+/lib/systemd/system(/.*)?systemd_unit_file_tSystemd unit files packaged within Nix store derivations./nix/var/nix/daemon-socket(/.*)?var_run_tThe Unix domain socket used for communication with the Nix daemon./nix/var/nix/profiles(/per-user/[^/]+)?/[^/]+usr_tNix profiles (which are symlinks pointing to specific store paths)./nix/var/nix/gcroots(/.*)?var_lib_tGarbage collection roots, critical for Nix's operation./nix/var/nix/db(/.*)?var_lib_tNix database files, storing metadata about derivations.Apply these file context rules:Bashsudo semanage fcontext -a -t etc_t '/nix/store/[^/]+/etc(/.*)?'
sudo semanage fcontext -a -t lib_t '/nix/store/[^/]+/lib(/.*)?'
sudo semanage fcontext -a -t bin_t '/nix/store/[^/]+/bin(/.*)?'
sudo semanage fcontext -a -t sbin_t '/nix/store/[^/]+/sbin(/.*)?'
sudo semanage fcontext -a -t usr_t '/nix/store/[^/]+/share(/.*)?'
sudo semanage fcontext -a -t systemd_unit_file_t '/nix/store/[^/]+/lib/systemd/system(/.*)?'
sudo semanage fcontext -a -t var_run_t '/nix/var/nix/daemon-socket(/.*)?'
sudo semanage fcontext -a -t usr_t '/nix/var/nix/profiles(/per-user/[^/]+)?/[^/]+'
sudo semanage fcontext -a -t var_lib_t '/nix/var/nix/gcroots(/.*)?'
sudo semanage fcontext -a -t var_lib_t '/nix/var/nix/db(/.*)?'
After adding the rules, apply them to the filesystem:Bashsudo restorecon -RF /nix
Creating Custom SELinux Policy Modules (if necessary)Even after meticulously applying file contexts, processes—particularly the nix-daemon and Nix build processes—may still encounter AVC denials for operations that are not covered by existing SELinux policy types or that require specific domain transitions not yet defined. In such scenarios, a custom SELinux policy module must be created to grant these necessary permissions.5Generating Policy Rules with audit2allow:The audit2allow utility is the primary tool for generating initial policy rules from the audit log.Command:Bashsudo audit2allow -a -M nix_custom_policy
This command analyzes the /var/log/audit/audit.log for AVC denials and generates two files: a Type Enforcement source file (e.g., nix_custom_policy.te) and a file context definition file (e.g., nix_custom_policy.fc).7Reviewing and Refining Generated .te Files:This is a crucial step. Blindly installing the output of audit2allow without review is a significant security risk, as it can inadvertently create overly permissive rules that undermine the system's security posture.5 Carefully inspect the generated .te file. Look for rules that grant excessively broad permissions (e.g., allow <source_type> <target_type>:{ file dir } { * };). The goal is to restrict permissions to only what is absolutely necessary (e.g., specific actions like read, write, execute on precise object classes).5 Pay particular attention to denials originating from nix-daemon and nixbld processes, as well as their interactions with /nix/store and its socket.This emphasizes the principle of least privilege in policy refinement. While audit2allow is a powerful tool for generating policy rules, it can often produce overly permissive rules if not carefully managed.5 The fundamental goal of SELinux is to enforce the principle of "deny by default" and "least privilege" 2, meaning processes should only have the exact permissions they need, no more. Simply allowing all actions suggested by audit2allow directly undermines the security benefits of SELinux. The guide places significant emphasis on the manual review and meticulous refinement of the audit2allow output. This requires the user to understand the granularity of SELinux permissions (e.g., read, write, execute, getattr, create, unlink) and object classes (file, dir, socket, process, capability). The process transforms from a reactive "fix-it" task to a deliberate security hardening exercise, where the user actively ensures that only the strictly necessary permissions are granted. This also implies that achieving a secure Nix-SELinux integration demands a deeper understanding of SELinux policy language beyond merely executing automated tools.Compiling and Installing the Module:Compile the Type Enforcement source file into a binary module:Bashsudo checkmodule -M -m -o nix_custom_policy.mod nix_custom_policy.te
``` [13]
Package the compiled module into a loadable policy package:Bashsudo semodule_package -o nix_custom_policy.pp nix_custom_policy.mod
``` [13]
Install the custom SELinux policy module:Bashsudo semodule -i nix_custom_policy.pp
``` [13]
Specific Considerations for nix-daemon and Systemd Unit Files:The nix-daemon is a privileged and central service in a multi-user Nix setup.11 It requires a dedicated SELinux domain (e.g., nix_daemon_t) and specific policy rules that allow it to manage the Nix store, interact with its Unix domain socket (/nix/var/nix/daemon-socket), and potentially facilitate domain transitions for nixbld users during build operations.7 Systemd, as the service manager, is deeply integrated with SELinux and plays a crucial role in managing service contexts.20 If the nix-daemon's systemd unit files (typically located within the Nix store at /nix/var/nix/profiles/default/lib/systemd/system/) are not correctly labeled or accessible, systemd might encounter issues starting or managing the daemon. Ensuring these unit files have the systemd_unit_file_t context is vital.12 The nix-daemon's socket, located at /nix/var/nix/daemon-socket/socket, typically requires the var_run_t context to allow proper communication.12While discussions exist regarding complex SELinux integration strategies for NixOS (e.g., using overlay filesystems for the immutable store8), for Fedora Workstation, the objective is to integrate Nix seamlessly into the existing SELinux framework. This primarily involves correctly labeling Nix's unique paths and granting the nix-daemon and its associated build processes the necessary, minimal permissions.A significant observation is the dynamic nature of Nix store paths and policy maintenance. Nix store paths are inherently dynamic, hash-based, and unique for each derivation.4 While semanage fcontext with regular expressions effectively addresses the labeling of types of files within the store (e.g., all etc directories within any derivation), new internal Nix mechanisms, changes in package dependencies, or major Nix updates might introduce new types of interactions, new file paths, or new process behaviors that are not covered by the existing custom policy. This means that the SELinux policy for Nix is not a "set it and forget it" solution. It requires ongoing maintenance and vigilance. With significant Nix updates or the installation of particularly complex or novel packages, new AVC denials might emerge, necessitating further iterative policy adjustments. The guide must prepare the user for this reality, emphasizing the need for periodic review of audit logs and a readiness to refine the custom policy module. This is a crucial long-term implication for maintaining a stable, secure, and functional Nix environment on Fedora.VI. Post-Installation Best Practices and TroubleshootingNix Multi-User Setup Refinementsnixbld Users and Groups: Confirm that the nixbld group and the designated nixbldX users (typically nixbld1 through nixbld10) have been correctly created and configured as per Nix's multi-user documentation.11 These users are fundamental for isolated and secure build operations.Create the nixbld group:Bashsudo groupadd -r nixbld
Create the nixbld users:Bashfor n in $(seq 1 10); do sudo useradd -c "Nix build user $n" -d /var/empty -g nixbld -G nixbld -M -N -r -s "$(which nologin)" nixbld$n; done
``` [11]
NIX_REMOTE=daemon for Users: For unprivileged users to effectively interact with the nix-daemon (which handles privileged operations on the store), they must have the NIX_REMOTE environment variable set to daemon. This ensures that user-initiated Nix commands are forwarded to the daemon for processing.11Add this line to your user's login shell configuration file (e.g., ~/.bashrc, ~/.profile, or ~/.zshrc):Bashexport NIX_REMOTE=daemon
After adding, source the file or open a new terminal session for the change to take effect.Restricting Access to the Nix Daemon Socket: To further enhance the security of your Nix installation, access to the Nix daemon's Unix domain socket (/nix/var/nix/daemon-socket/socket) can be explicitly restricted to members of a specific group (e.g., nix-users). This prevents unauthorized processes or users from interacting with the daemon.11Create a nix-users group:Bashsudo groupadd nix-users
Add your user to this group:Bashsudo usermod -aG nix-users <your_username>
Change the group ownership of the daemon socket directory:Bashsudo chgrp nix-users /nix/var/nix/daemon-socket
Set permissions to allow only owner and group members read/write/execute access:Bashsudo chmod ug=rwx,o= /nix/var/nix/daemon-socket
``` [11]
Ensure that the nixbld users (if they are not automatically part of nix-users) also have appropriate permissions to access this socket for build operations.Addressing GUI Application Issues with nixGLProblem: Nix packages, particularly graphical user interface (GUI) applications, frequently encounter issues with OpenGL/Vulkan libraries on non-NixOS distributions. This occurs because Nix packages are built to look for libraries within Nix's unique store paths, while the underlying host OS (Fedora) provides its own graphics drivers and libraries in standard system locations.9 This mismatch leads to "library errors" and applications failing to launch.Solution: nixGL is a specialized wrapper designed to ensure that Nix packages can correctly find and utilize the necessary host-system graphical libraries. This addresses a practical consequence of Nix's design on a non-NixOS system, requiring a specific workaround that is not directly SELinux-related but critical for a "general environment" experience.Installation: Add the nixGL channel to your Nix configuration and install it:Bashnix-channel --add https://github.com/guibou/nixGL/archive/main.tar.gz nixgl
nix-channel --update
nix-env -iA nixgl.nixgl
Usage: To run a GUI application installed via Nix, simply prefix its command with nixGLIntel (for Intel/AMD GPUs) or nixGLNvidia (for Nvidia GPUs).9Example for Firefox:BashnixGLIntel firefox
Example for Blender:BashnixGLNvidia blender
Troubleshooting Persistent SELinux DenialsIf AVC denials persist despite applying the initial file contexts and custom policy modules, a systematic troubleshooting approach is required.Re-evaluating File Contexts and Policy Rules:Revisit the ausearch output to identify the latest denials.Double-check that the semanage fcontext rules you defined are correctly applied and specific enough for the problematic paths. Use ls -Z <path> to verify the actual SELinux context of the problematic files or directories.1Confirm that restorecon -RF /nix has been run after adding any new fcontext rules.12Verify that your custom policy modules (.pp files) are installed and active. You can list all installed modules with semodule -l.Remember that SELinux rules are checked after DAC rules (traditional Linux permissions). If DAC denies access, SELinux won't even be consulted, and no AVC will be logged.2Using sealert for Detailed Analysis: For complex or cryptic AVC denials, the sealert utility can provide more human-readable explanations and often suggest specific solutions.15Command:Bashsudo sealert -l <alert_id>
The <alert_id> is a unique identifier found within the AVC denial message in the audit log.Temporarily Setting Specific Domains to Permissive Mode: Instead of switching the entire system to permissive mode, for targeted debugging, you can set only the problematic SELinux domain (process type) to permissive. This allows the specific process to run without being blocked by SELinux, while still logging all denials, providing clearer audit information for policy refinement.7Command:Bashsudo semanage permissive -a <problematic_domain_t>
(e.g., sudo semanage permissive -a nix_daemon_t if you created such a type).To revert this change and re-enforce the domain:Bashsudo semanage permissive -d <problematic_domain_t>
Table 2: Common SELinux AVC Denial Fields and Their MeaningThis table helps users quickly interpret the verbose AVC denial messages, which are often the starting point for troubleshooting. Understanding these fields is fundamental to diagnosing and resolving SELinux issues.7 AVC messages are notoriously dense and difficult for newcomers to parse.6 Providing a clear breakdown of each field directly addresses this pain point, enabling the user to quickly identify the source process, the target resource, the type of access denied, and the relevant SELinux contexts. This table is an essential troubleshooting tool, allowing the user to move from "error message" to "actionable information." It supports the iterative troubleshooting process by making the initial diagnostic step more efficient.FieldDescriptionExample ValuetypeThe type of audit record.AVCmsgThe full audit message, including timestamp and serial number.audit(1395177286.929:1638): avc: denied { read }pidProcess ID of the process that attempted the action.6591commCommand name of the process that attempted the action.httpdnameName of the file or object being accessed.webpagesdevDevice identifier where the object resides.0:37, dm-0, sdb1inoInode number of the object.2112, 284133scontextSource security context (label of the process).system_u:system_r:httpd_t:s0tcontextTarget security context (label of the object being accessed).system_u:object_r:nfs_t:s0, unconfined_u:object_r:samba_share_t:s0tclassTarget object class (e.g., file, dir, socket).dir, filedenied { permissions }The specific permissions that were denied.{ read }, { getattr }A crucial observation is the layered troubleshooting approach. Troubleshooting involves systematically checking file contexts using ls -Z and restorecon, then analyzing audit logs with ausearch and sealert, and finally considering custom policy modules generated via audit2allow and installed with semodule. There is also the option of using targeted permissive mode. This suggests a systematic, layered approach to troubleshooting SELinux with Nix. It is not just about fixing one denial, but understanding the hierarchy of SELinux enforcement: DAC rules are checked first, followed by file contexts, then process domains, and finally specific policy rules. The guide presents troubleshooting as a methodical process, starting with verifying labels, then analyzing denials, and only then generating custom rules. This prevents unnecessary policy complexity and ensures a more secure outcome.Another important observation is the community policy gap and user responsibility. The research highlights that the official Nix installer has SELinux issues on Fedora 4, and that a "proper fix" (e.g., an RPM with integrated policy) is being worked on but is not yet available.12 Determinate Nix addresses this directly.17 This means the user is effectively filling a gap in official SELinux policy support for Nix on Fedora. The user, by following this guide, is taking on the responsibility of maintaining a custom SELinux policy for a third-party package manager. This requires ongoing vigilance and a commitment to understanding SELinux fundamentals. The guide subtly conveys this responsibility, emphasizing the "why" behind the steps, not just the "how," to empower the user for long-term maintenance. This also implies that while the guide provides a solution, it is a workaround for a current lack of official integration, underscoring the dynamic nature of Linux security and package management.VII. ConclusionSuccessfully integrating the Nix package manager with SELinux on Fedora Workstation 42 is a nuanced task that demands a methodical approach to policy customization. By meticulously defining file contexts for the /nix/store and its subdirectories, and by carefully crafting precise SELinux policy modules for the nix-daemon and other associated processes, a robust and secure environment can be achieved. This configuration allows users to fully leverage Nix's powerful, reproducible package management capabilities while simultaneously upholding Fedora's strong security posture, which is inherently provided by SELinux.A properly configured SELinux policy, even when dealing with a complex and unconventional system like Nix, significantly enhances system security. It enforces the principle of least privilege, ensuring that processes and files only access what they are explicitly allowed to. This confinement limits the potential damage from software vulnerabilities or misconfigurations, preventing lateral movement within the system and unauthorized data access.2It is important to acknowledge that the landscape of Nix-SELinux integration is continuously evolving. While this guide provides a functional and robust solution for Fedora Workstation 42, the community is actively working towards more seamless and officially supported SELinux integration for Nix. This includes efforts seen in the Determinate Nix Installer 16, which offers pre-configured policies, and ongoing discussions around advanced techniques like overlay filesystems for the Nix store.8 These developments indicate that while the current manual steps are effective, future Nix or Fedora updates may introduce more automated and integrated solutions. Users are encouraged to stay informed about these upstream developments and consider contributing to these efforts, as this will further enhance the security and usability of Nix on SELinux-enabled systems. This highlights that the manual approach detailed here might eventually become obsolete, but the principles of SELinux policy creation and troubleshooting will remain relevant.
